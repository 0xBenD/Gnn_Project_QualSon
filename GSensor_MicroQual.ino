//-----------------------------------------------------------------------------
//
// Sensor Measurement (Signal from microphone).
//
//  Read the comments and understand the program.
//  Replace the “????” with a suitable value before running the program.
//
// Step-1 : Goto ##TAG##1 Set the sensor pin and determine SAMPLE_FREQ and SIZE_BUFF
// Step-2 : Goto ##TAG##2 read and understand the sampling function
//              Il ne faut rien modifier
// Step-3 : Goto ##TAG##3 Translate your Matlab program to calculate the mean power
//              and signal frequency
// Step-4 : Goto ##TAG##4 Complete the main program Sensor_Measure()
//-----------------------------------------------------------------------------

#include    "Gnx_Project_QualSon.h"


// ##TAG##1 deb
#define   SENSOR_PIN  PD_3

// Define the sampling parameters
//---------------------------------------------------------------
//  Choose the sampling frequency : integer value in KHz (example 10 for 10 KHz)
#define   SAMPLE_FREQ   10

//  Sampling period in micro-secondes for project with microphone
#define   SAMPLE_PERIOD (1000/SAMPLE_FREQ)

//  Choose the size of samples buffer
// Depending on your project, determine the number to have 
// the desired recording duration   /* value between 1000 and 4000  */
#define   SIZE_BUFF 2500



// Nombre d'echantillons correspondant K
#define   LEN_K (SAMPLE_FREQ*5)

#define   SIZE_AUTOCORR (SIZE_BUFF/2)
// Buffer of autocorrelztion
float Buff_AutoCorr[SIZE_AUTOCORR];
// ##TAG##1 end



void  Read_Samples(float Buffer_Sample[SIZE_BUFF]);
float myPowerEstimation(float Buffer_Sample[SIZE_BUFF]);
short myPowerFiltrage( void);


// ##TAG##4 deb
// You must determine the power measured with no Signal
// this is the low level value in the below line
#define   LOW_LEVEL   30

short Sensor_Measure(void)
//-----------------------------------------------------
// Main Fonction 
//-----------------------------------------------------
{
  // Déclaration de variables
  float SignalPower;    // puissance du Son
  float PowerOver2K;    // pourcentage de puissance au dela de 2 KHz
  short SigPenible;
  // Signal samples Buffer 
  float Buffer_Sample[SIZE_BUFF];

  Serial.println(" ");
  Serial.println("--- Signal Power Measurement ---");

  // call function : get buffer samples of signal
  // call function : get power signal
  SignalPower = myPowerEstimation(Buffer_Sample);

  // Display the result
  Serial.print(" Power = ");    Serial.println(SignalPower);
  if (SignalPower < LOW_LEVEL) {
    // Power is too low = no signal
    // display an explicit message and turn on the white LED
    SigPenible = -1;  // Pas de signal
  }
  else {
    // acceptable power
    // display an explicit message and turn on the green LED
    // Calcul de la puissance apres 2 KHz
    //PowerOver2K = 100*(SignalPower - myPowerFiltrage(SignalPower))/SignalPower;
    
    // Determiner si le signal est penible 
    // SigPenible = 0 => acceptable, ( > 0 ) => niveau de penibilite
    // SigPenible = ......  
  }
  return SigPenible;
}
// ##TAG##4 end


// ##TAG##3 deb
float myPowerEstimation(float Buffer_Sample[SIZE_BUFF])
//------------------------------------------------------------------------------
//  Read signal and compute mean power
//------------------------------------------------------------------------------
{
  float power;
  // add some local variables
  float  ech, pwr_sum, sumfen, pval, val_moy;
  short  n, k, szfen;
 // Buffer of Instantaneous power
float Power_Inst[SIZE_BUFF];


  power = 0;
  // center the signal : <signal> = <signal> - 0 (no continuous component)
  //
  // compute mean power
  // Calcul de la puissance instantannée en floatant
  pwr_sum = 0.0;    pval = 0.0;
  for (n = 0; n < LEN_K; n++) {
    sumfen = 0.0; szfen = n + LEN_K;
    for(int j = 0; j < szfen; j++){
      sumfen += pow(Buffer_Sample[j],2);
    }
    pval = sumfen / szfen;
    Power_Inst[n] = pval;
    pwr_sum = pwr_sum + pval;
  }
  for (n = LEN_K; n < (SIZE_BUFF - LEN_K); n++) {
    sumfen = 0.0; szfen = (2*LEN_K) + 1;
    for(int j = n - LEN_K; j < n + LEN_K; j++){
      sumfen += pow(Buffer_Sample[j],2);
    }
    pval = sumfen / szfen;
    Power_Inst[n] = pval;
    pwr_sum = pwr_sum + pval;
  }
  for (n = SIZE_BUFF - LEN_K; n < SIZE_BUFF; n++) {
    sumfen = 0.0; szfen = SIZE_BUFF - n + LEN_K;
    for(int j = SIZE_BUFF - LEN_K; j < LEN_K; j++){
      sumfen += pow(Buffer_Sample[j],2);
    }
    pval = sumfen / szfen;
    Power_Inst[n] = pval;
    pwr_sum = pwr_sum + pval;
  }
  // calculer la puissance moyenne
  power = pwr_sum / SIZE_BUFF;
  return power;
}

const float h[151] = {
  -0.003271630291508422633262043177637679037,
0.016691072074447890066783983797904511448,
-0.010308430392768215891341476719844649779,
-0.003348048712782572284424320585571877018,
0.003824847571323500370482628696322535689,
0.003821317948156630756040286200914124493,
-0.000503823018561026770255339979343034429,
-0.003378613809875573217172961548726561887,
-0.001843691625468539757939923084961719724,
0.001837562328404052482480612873416703223,
0.003063244162523189473984475128531812516,
0.000354845267180232265546990788607217837,
-0.002844240743001642465759282174531108467,
-0.002371302592575480483461092262587044388,
0.001266432615831659166255596105088443437,
0.003367768489748912148079584838455957652,
0.001034377835516646923844086281008003425,
-0.002825172642033972354030924023504667275,
-0.003064705812558921223243135756320043583,
0.000855689877246729765740418383046517192,
0.003851488584040804567798499391528821434,
0.001767723015742027597302366004328177951,
-0.002876138289414619745448797871745227894,
-0.003876120550461281417248260439123441756,
0.0003796396611880658070702077022673393,
0.004402480583288915713668920659529248951,
0.00264286849332998063921706943801837042,
-0.002879165118748241644630603275345492875,
-0.004816430658136102924138377545659750467,
-0.000250414848434600751433259935296860021,
0.004982173140346115268461968383917337633,
0.00371358172503563361416256682900893793,
-0.002772758831251239015902587681239310768,
-0.005899730385985867998910325837869095267,
-0.001104667032571757289208247421186115389,
0.005570853049570612114393952651880681515,
0.00504013748479158456977655689001949213 ,
-0.002499139333941349881001992017104385013,
-0.007152174789217284264775109647871431662,
-0.002266580691135697527699432995973438665,
0.006138625021032104861484768321133742575,
0.006704188432828471662372482597902489942,
-0.00197774445453689946827768864068275434 ,
-0.00862558519683809254985362713341601193 ,
-0.00385473408570630561922887302728213399 ,
0.006678336940941976239416444371954639792,
0.008838043922073565358821234383412956959,
-0.001113032826761336602575114262947408861,
-0.010414479578893741026912600489140459104,
-0.006054857830667088360032668248322806903,
0.007175029457212693355383503757138896617,
0.011666086951893818099423860701335797785,
0.000279531894883749151923396647489994393,
-0.012683654334945169625536998125880927546,
-0.009237315668412481028948235461939475499,
0.007596396739522728695781506047524089809,
0.01569223471980374026713001001098746201 ,
0.002588471970598852332778871954133137478,
-0.01587131641892523814529880610280088149 ,
-0.014245728805406861899873760535228939261,
0.007951298041823687615115012761179968948,
0.022114510143647746892581196220817219,
0.00673164168511811850104109566927945707,
-0.021095930031642319557594333900851779617,
-0.023433430372313265172001806035950721707,
0.008207120529415265139383528492089681095,
0.034889374348757190569259023504855576903,
0.015970561903532784486792195366433588788,
-0.032819824135607127135738636525275069289,
-0.047017279189628419233670797439117450267,
0.008368033486355683572832653283057879889,
0.077685547400759252800739318445266690105,
0.055307240839937807375115141894639236853,
-0.100171297462451971971297837171732680872,
-0.299984500285878197267663836100837215781,
0.60841337835031805703067675494821742177,
-0.299984500285878197267663836100837215781,
-0.100171297462451971971297837171732680872,
0.055307240839937807375115141894639236853,
0.077685547400759252800739318445266690105,
0.008368033486355683572832653283057879889,
-0.047017279189628419233670797439117450267,
-0.032819824135607127135738636525275069289,
0.015970561903532784486792195366433588788,
0.034889374348757190569259023504855576903,
0.008207120529415265139383528492089681095,
-0.023433430372313265172001806035950721707,
-0.021095930031642319557594333900851779617,
0.00673164168511811850104109566927945707,
0.022114510143647746892581196220817219,
0.007951298041823687615115012761179968948,
-0.014245728805406861899873760535228939261,
-0.01587131641892523814529880610280088149,
0.002588471970598852332778871954133137478,
0.01569223471980374026713001001098746201,
0.007596396739522728695781506047524089809,
-0.009237315668412481028948235461939475499,
-0.012683654334945169625536998125880927546,
0.000279531894883749151923396647489994393,
0.011666086951893818099423860701335797785,
0.007175029457212693355383503757138896617,
-0.006054857830667088360032668248322806903,
-0.010414479578893741026912600489140459104,
-0.001113032826761336602575114262947408861,
0.008838043922073565358821234383412956959,
0.006678336940941976239416444371954639792,
-0.00385473408570630561922887302728213399,
-0.00862558519683809254985362713341601193,
-0.00197774445453689946827768864068275434,
0.006704188432828471662372482597902489942,
0.006138625021032104861484768321133742575,
-0.002266580691135697527699432995973438665,
-0.007152174789217284264775109647871431662,
-0.002499139333941349881001992017104385013,
0.00504013748479158456977655689001949213,
0.005570853049570612114393952651880681515,
-0.001104667032571757289208247421186115389,
-0.005899730385985867998910325837869095267,
-0.002772758831251239015902587681239310768,
0.00371358172503563361416256682900893793,
0.004982173140346115268461968383917337633,
-0.000250414848434600751433259935296860021,
-0.004816430658136102924138377545659750467,
-0.002879165118748241644630603275345492875,
0.00264286849332998063921706943801837042,
0.004402480583288915713668920659529248951,
0.0003796396611880658070702077022673393,
-0.003876120550461281417248260439123441756,
-0.002876138289414619745448797871745227894,
0.001767723015742027597302366004328177951,
0.003851488584040804567798499391528821434,
0.000855689877246729765740418383046517192,
-0.003064705812558921223243135756320043583,
-0.002825172642033972354030924023504667275,
0.001034377835516646923844086281008003425,
0.003367768489748912148079584838455957652,
0.001266432615831659166255596105088443437,
-0.002371302592575480483461092262587044388,
-0.002844240743001642465759282174531108467,
0.000354845267180232265546990788607217837,
0.003063244162523189473984475128531812516,
0.001837562328404052482480612873416703223,
-0.001843691625468539757939923084961719724,
-0.003378613809875573217172961548726561887,
-0.000503823018561026770255339979343034429,
0.003821317948156630756040286200914124493,
0.003824847571323500370482628696322535689,
-0.003348048712782572284424320585571877018,
-0.010308430392768215891341476719844649779,
0.016691072074447890066783983797904511448,
-0.003271630291508422633262043177637679037
};

}
short myPowerFiltrage(float filteredSignal[])

//------------------------------------------------------------------------------
//  compute signal frequency Power : par Filtrage
//------------------------------------------------------------------------------
{ 

    for (int n = 0; n < SIZE_BUFF; n++)
    {
      for (int i = 0; i < 151; i++)
      {
      if (n - i < 0) break; 
      filteredSignal[n] += h[i] * Buffer_Sample[n - i]; //FIR filter equation with h[i] the FIR filter coeff, Buffer_Sample[] the input signal, and y the filtered output
      }
    }    
    
}
// ##TAG##3 end


// ##TAG##2 deb
void  Sensor_Init(void)
//-----------------------------------------------------
// Initialization function 
//-----------------------------------------------------
{
  // Serial port baud rate = 9600 bauds
  Serial.begin(9600);
  // Initialize the sensor input as an analog input
  pinMode(SENSOR_PIN, INPUT);
}

#define   ADC_MAX_VDD   3.3
#define   ADC_MAX_NUM   4095

void  Read_Samples(float Buffer_Sample[SIZE_BUFF])
//------------------------------------------------------------------------------
// Do Not modify this function. Read and understand
//------------------------------------------------------------------------------
{ float val_float;
  short val_integer;    unsigned long curtime, nextime;

  // See help of 'micros()' function in Energia
  // compute next sampling time (nextime)
  nextime = micros() + SAMPLE_PERIOD;
  for(short idx_sample = 0; idx_sample < SIZE_BUFF; idx_sample++){
    // wait time of next sample (nextime)
    do {
      curtime = micros();
    } while (curtime < nextime);
    // read sample
    val_integer = analogRead(SENSOR_PIN);
    val_float = ((float)val_integer*ADC_MAX_VDD)/ADC_MAX_NUM;
    Buffer_Sample[idx_sample] = val_float;
    // update next sample time
    nextime += SAMPLE_PERIOD;
  }
  return;
}
// ##TAG##2 end
